<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kitchen Sync - Multi-Dish Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
        }

        .step-card {
            transition: all 0.3s ease;
        }

        .active-step {
            border-color: #3b82f6;
            background-color: #eff6ff;
            transform: scale(1.02);
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.1);
        }

        .pulse {
            animation: pulse-animation 2s infinite;
        }

        @keyframes pulse-animation {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div id="app" class="max-w-4xl mx-auto">
        <!-- Header -->
        <header class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-slate-800 mb-2">Kitchen Sync</h1>
            <p class="text-slate-600">Coordinate your cooking so everything finishes together.</p>
        </header>

        <!-- Main Timer Display (Only shown when running) -->
        <div id="active-timer-section" class="hidden mb-8 space-y-4">
            <!-- Global Time and Current Tasks -->
            <div class="bg-white p-8 rounded-2xl shadow-xl border border-blue-100 text-center">
                <div class="text-sm font-bold text-slate-400 uppercase tracking-widest mb-1">Time to Finish</div>
                <div class="text-7xl font-mono font-bold text-slate-800 mb-6" id="global-countdown">00:00</div>

                <div class="text-sm font-bold text-blue-500 uppercase tracking-widest mb-2">Current Tasks</div>
                <div id="current-instruction" class="text-2xl font-semibold text-slate-700 mb-2 italic min-h-[3rem]">
                    Waiting to start...
                </div>
            </div>

            <!-- Coming Up Next Section -->
            <div id="next-step-card" class="bg-blue-50 p-6 rounded-2xl border-2 border-dashed border-blue-200 text-center">
                <div class="text-xs font-bold text-blue-400 uppercase tracking-widest mb-1">Coming Up Next</div>
                <div id="next-step-timer" class="text-3xl font-mono font-bold text-blue-600 mb-1">--:--</div>
                <div id="next-step-desc" class="text-lg text-blue-800 font-medium italic">Loading next step...</div>
            </div>

            <div class="flex justify-center gap-4 mt-6">
                <button onclick="stopTimer()" class="px-8 py-3 bg-slate-200 hover:bg-slate-300 text-slate-700 rounded-full font-bold transition">Stop & Edit</button>
            </div>
        </div>

        <!-- Configuration Section -->
        <div id="config-section" class="space-y-6">
            <!-- Save/Load Bar -->
            <div class="bg-white p-4 rounded-xl shadow-sm border border-slate-200 flex flex-wrap gap-4 items-center justify-between">
                <div class="flex gap-2 items-center flex-grow">
                    <input type="text" id="recipe-name" placeholder="Meal Name (e.g. Sunday Roast)" class="flex-grow p-2 border rounded-lg outline-none focus:ring-2 focus:ring-blue-400">
                    <button onclick="saveRecipe()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold transition">Save Meal</button>
                </div>
                <div class="flex gap-2 items-center">
                    <select id="saved-recipes-dropdown" onchange="loadRecipe(this.value)" class="p-2 border rounded-lg outline-none bg-slate-50">
                        <option value="">Load a Saved Meal...</option>
                    </select>
                    <button onclick="deleteRecipe()" class="text-red-400 hover:text-red-600 p-2">✕</button>
                </div>
            </div>

            <div id="dishes-container" class="space-y-4">
                <!-- Dishes will be injected here -->
            </div>

            <div class="flex flex-col sm:flex-row gap-4 pt-4">
                <button onclick="addDish()" class="flex-1 bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-4 rounded-xl transition">
                    + Add Another Dish
                </button>
                <button onclick="clearAll()" class="sm:w-32 bg-slate-100 hover:bg-red-50 text-slate-500 hover:text-red-500 font-bold py-4 rounded-xl transition">
                    Clear All
                </button>
                <button onclick="startCooking()" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-4 rounded-xl shadow-lg transition transform hover:-translate-y-1">
                    START COOKING
                </button>
            </div>
        </div>
    </div>

    <script>
        let dishes = [];

        let timerInterval = null;
        let totalTimeSeconds = 0;
        let elapsedSeconds = 0;
        let schedule = [];

        function renderDishes() {
            const container = document.getElementById('dishes-container');
            container.innerHTML = '';
            dishes.forEach((dish, dIdx) => {
                const dishEl = document.createElement('div');
                dishEl.className = 'bg-white p-6 rounded-xl shadow-sm border border-slate-200';
                dishEl.innerHTML = `
                    <div class="flex justify-between items-center mb-4">
                        <input type="text" value="${dish.name}" onchange="updateDishName(${dIdx}, this.value)"
                            class="text-xl font-bold text-slate-800 border-b border-transparent hover:border-slate-300 focus:border-blue-500 outline-none bg-transparent">
                        <button onclick="removeDish(${dIdx})" class="text-red-400 hover:text-red-600">✕</button>
                    </div>
                    <div class="space-y-2 mb-4" id="steps-${dIdx}">
                        ${dish.steps.map((step, sIdx) => `
                            <div class="flex gap-2 items-center">
                                <input type="text" placeholder="Step description" value="${step.text}" onchange="updateStepText(${dIdx}, ${sIdx}, this.value)"
                                    class="flex-grow p-2 bg-slate-50 rounded border border-slate-200 text-sm">
                                <input type="number" step="0.1" placeholder="Mins" value="${step.mins}" onchange="updateStepMins(${dIdx}, ${sIdx}, this.value)"
                                    class="w-16 p-2 bg-slate-50 rounded border border-slate-200 text-sm">
                                <span class="text-xs text-slate-400">min</span>
                                <button onclick="removeStep(${dIdx}, ${sIdx})" class="text-slate-300 hover:text-red-400 text-xs">✕</button>
                            </div>
                        `).join('')}
                    </div>
                    <button onclick="addStep(${dIdx})" class="text-blue-500 hover:text-blue-700 text-sm font-semibold">+ Add Step</button>
                `;
                container.appendChild(dishEl);
            });
            updateSavedRecipesList();
        }

        function addDish() {
            dishes.push({ id: Date.now(), name: "New Dish", steps: [{ text: "New step", mins: 5 }] });
            renderDishes();
        }

        function clearAll() {
            if(confirm("Clear current recipe?")) {
                dishes = [];
                renderDishes();
            }
        }

        function removeDish(idx) {
            dishes.splice(idx, 1);
            renderDishes();
        }

        function addStep(dIdx) {
            dishes[dIdx].steps.push({ text: "", mins: 1 });
            renderDishes();
        }

        function removeStep(dIdx, sIdx) {
            dishes[dIdx].steps.splice(sIdx, 1);
            renderDishes();
        }

        function updateDishName(idx, val) { dishes[idx].name = val; }
        function updateStepText(dIdx, sIdx, val) { dishes[dIdx].steps[sIdx].text = val; }
        function updateStepMins(dIdx, sIdx, val) { dishes[dIdx].steps[sIdx].mins = parseFloat(val) || 0; }

        function saveRecipe() {
            const name = document.getElementById('recipe-name').value.trim();
            if (!name) { alert("Please enter a name for the meal."); return; }
            const savedRecipes = JSON.parse(localStorage.getItem('kitchenSyncRecipes') || '{}');
            savedRecipes[name] = dishes;
            localStorage.setItem('kitchenSyncRecipes', JSON.stringify(savedRecipes));
            updateSavedRecipesList();
        }

        function loadRecipe(name) {
            if (!name) return;
            const savedRecipes = JSON.parse(localStorage.getItem('kitchenSyncRecipes') || '{}');
            if (savedRecipes[name]) {
                dishes = JSON.parse(JSON.stringify(savedRecipes[name]));
                document.getElementById('recipe-name').value = name;
                renderDishes();
            }
        }

        function deleteRecipe() {
            const dropdown = document.getElementById('saved-recipes-dropdown');
            const name = dropdown.value;
            if (!name) return;
            if (confirm(`Delete saved meal "${name}"?`)) {
                const savedRecipes = JSON.parse(localStorage.getItem('kitchenSyncRecipes') || '{}');
                delete savedRecipes[name];
                localStorage.setItem('kitchenSyncRecipes', JSON.stringify(savedRecipes));
                updateSavedRecipesList();
            }
        }

        function updateSavedRecipesList() {
            const dropdown = document.getElementById('saved-recipes-dropdown');
            const savedRecipes = JSON.parse(localStorage.getItem('kitchenSyncRecipes') || '{}');
            const currentVal = dropdown.value;
            dropdown.innerHTML = '<option value="">Load a Saved Meal...</option>';
            Object.keys(savedRecipes).sort().forEach(name => {
                const opt = document.createElement('option');
                opt.value = name; opt.textContent = name;
                dropdown.appendChild(opt);
            });
            dropdown.value = currentVal;
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        function startCooking() {
            if (dishes.length === 0) return;
            schedule = [];
            let maxDuration = 0;

            dishes.forEach(dish => {
                let dishTotal = dish.steps.reduce((acc, s) => acc + s.mins, 0);
                if (dishTotal > maxDuration) maxDuration = dishTotal;
            });

            totalTimeSeconds = maxDuration * 60;
            elapsedSeconds = 0;

            dishes.forEach(dish => {
                let dishTotal = dish.steps.reduce((acc, s) => acc + s.mins, 0);
                let currentStartTime = (maxDuration - dishTotal) * 60;
                dish.steps.forEach(step => {
                    schedule.push({
                        dishName: dish.name,
                        instruction: step.text,
                        startTimeSeconds: Math.round(currentStartTime),
                        durationSeconds: Math.round(step.mins * 60)
                    });
                    currentStartTime += step.mins * 60;
                });
            });

            schedule.sort((a, b) => a.startTimeSeconds - b.startTimeSeconds);
            document.getElementById('config-section').classList.add('hidden');
            document.getElementById('active-timer-section').classList.remove('hidden');
            runTimer();
        }

        function runTimer() {
            if (timerInterval) clearInterval(timerInterval);
            updateDisplay();
            timerInterval = setInterval(() => {
                elapsedSeconds++;
                if (elapsedSeconds >= totalTimeSeconds) {
                    clearInterval(timerInterval);
                    document.getElementById('global-countdown').innerText = "DONE!";
                    document.getElementById('current-instruction').innerText = "Everything is ready!";
                    document.getElementById('next-step-card').classList.add('hidden');
                    playAlert();
                } else {
                    updateDisplay();
                }
            }, 1000);
        }

        function updateDisplay() {
            const timeLeft = totalTimeSeconds - elapsedSeconds;
            document.getElementById('global-countdown').innerText = formatTime(timeLeft);

            // Active Tasks
            const activeActions = schedule.filter(s =>
                elapsedSeconds >= s.startTimeSeconds &&
                elapsedSeconds < (s.startTimeSeconds + s.durationSeconds)
            );

            // Alert for new items starting exactly now
            const startingNow = schedule.find(s => s.startTimeSeconds === elapsedSeconds);
            if (startingNow) playAlert();

            if (activeActions.length > 0) {
                const text = activeActions.map(a => `<div><span class="text-blue-500">[${a.dishName}]</span> ${a.instruction}</div>`).join('');
                document.getElementById('current-instruction').innerHTML = text;
            } else {
                document.getElementById('current-instruction').innerText = "Wait for next step...";
            }

            // "Coming Up Next" Logic
            // Find the first instruction that has NOT started yet
            const nextAction = schedule.find(s => s.startTimeSeconds > elapsedSeconds);
            const nextCard = document.getElementById('next-step-card');

            if (nextAction) {
                nextCard.classList.remove('hidden');
                const timeToNext = nextAction.startTimeSeconds - elapsedSeconds;
                document.getElementById('next-step-timer').innerText = `-${formatTime(timeToNext)}`;
                document.getElementById('next-step-desc').innerText = `[${nextAction.dishName}] ${nextAction.instruction}`;
            } else {
                nextCard.classList.add('hidden');
            }
        }

        function stopTimer() {
            clearInterval(timerInterval);
            document.getElementById('config-section').classList.remove('hidden');
            document.getElementById('active-timer-section').classList.add('hidden');
        }

        function playAlert() {
            const display = document.getElementById('active-timer-section');
            display.classList.add('pulse');
            setTimeout(() => display.classList.remove('pulse'), 2000);
            try {
                const context = new (window.AudioContext || window.webkitAudioContext)();
                const osc = context.createOscillator();
                const gain = context.createGain();
                osc.connect(gain);
                gain.connect(context.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, context.currentTime);
                gain.gain.setValueAtTime(0, context.currentTime);
                gain.gain.linearRampToValueAtTime(0.1, context.currentTime + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + 0.5);
                osc.start();
                osc.stop(context.currentTime + 0.5);
            } catch (e) {}
        }

        renderDishes();
    </script>
</body>
</html>